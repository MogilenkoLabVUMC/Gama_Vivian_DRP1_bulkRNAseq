#!/usr/bin/env python3
"""
Interactive Bump Chart Generator (Plotly)
=========================================

Generates standalone HTML interactive bump charts for various configurations.
Matches the variants generated by the static bump chart script (excluding highlights).

Features:
- Tooltips with detailed info (Pathway, Database, NES/p-adj for Early/TrajDev/Late, Pattern, Reason).
- Toggling of pattern categories via legend.
- Variants: Uniform/Weighted, NES/Rank, Curved/Straight.
- Scopes: Focused, Significant.
"""

import sys
from pathlib import Path
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Add module paths
sys.path.insert(0, str(Path(__file__).parent.parent / '01_Scripts'))

from Python.config import resolve_path
from Python.viz_bump_charts import load_data, filter_by_scope, compute_weight_categories, get_bezier_curve
from Python.pattern_definitions import get_pattern_colors, PATTERN_DEFINITIONS

OUTPUT_DIR = resolve_path('03_Results/02_Analysis/Plots/Trajectory_Flow/bump')  # Interactive variants go to bump subfolder
PATTERN_COLORS = get_pattern_colors()

# =============================================================================
# DATA PREPARATION
# =============================================================================

def prepare_data_with_pvals(df):
    """
    Pivot p-values and merge to create a wide-format dataframe with all stats.
    """
    # Create mapping for column renaming
    contrast_map = {
        'G32A_vs_Ctrl_D35': 'padj_Early_G32A',
        'G32A_vs_Ctrl_D65': 'padj_Late_G32A',
        'Maturation_G32A_specific': 'padj_TrajDev_G32A',
        'R403C_vs_Ctrl_D35': 'padj_Early_R403C',
        'R403C_vs_Ctrl_D65': 'padj_Late_R403C',
        'Maturation_R403C_specific': 'padj_TrajDev_R403C',
    }
    
    # Check if we have the needed contrasts
    available_contrasts = df['contrast'].unique()
    
    # Pivot p.adjust
    # We only care about the contrasts in our map
    df_filtered = df[df['contrast'].isin(contrast_map.keys())]
    
    pvals = df_filtered.pivot(index='pathway_id', columns='contrast', values='p.adjust')
    pvals = pvals.rename(columns=contrast_map)
    
    # Base dataframe (unique pathways)
    # We pick the first occurrence as the 'wide' NES columns are repeated
    df_base = df.drop_duplicates(subset=['pathway_id']).copy()
    
    # Join
    df_final = df_base.set_index('pathway_id').join(pvals).reset_index()
    
    return df_final

def get_significance_star(pval):
    """Return * if significant, else empty string."""
    if pd.isna(pval): return ""
    return "*" if pval < 0.05 else ""

def get_pattern_desc(pattern):
    """Get generic description for the pattern."""
    if pattern in PATTERN_DEFINITIONS:
        return PATTERN_DEFINITIONS[pattern].get('interpretation', 'No description available.')
    return ""

# =============================================================================
# PLOTTING LOGIC
# =============================================================================

def create_interactive_plot(df, config):
    """
    Create a Plotly interactive bump chart based on config.
    Config dict keys: scope, mode (uniform/weighted), y_type (nes/rank), curve (bool)
    """
    scope = config['scope']
    mode = config['mode']
    y_type = config['y_type']
    use_curve = config.get('curve', False)
    
    print(f"Generating interactive plot: {scope} | {mode} | {y_type} | curve={use_curve}")
    
    # Filter data
    df_scope = filter_by_scope(df, scope)
    if len(df_scope) == 0:
        print("  Skipping: No data")
        return

    # Calculate Weights if needed
    weight_cats = None
    if mode == 'weighted':
        weight_cats = compute_weight_categories(df_scope)

    # Calculate Ranks if needed
    if y_type == 'rank':
        for mut in ['G32A', 'R403C']:
            for s in ['Early', 'Late']:
                col = f'NES_{s}_{mut}'
                rank_col = f'Rank_{s}_{mut}'
                # Rank 1 is highest NES (descending)
                if col in df_scope.columns:
                    df_scope[rank_col] = df_scope[col].rank(ascending=False, method='first')

    # Figure Setup
    fig = make_subplots(
        rows=1, cols=2,
        subplot_titles=("G32A Mutation", "R403C Mutation"),
        shared_yaxes=True, # Share Y axis
        horizontal_spacing=0.05
    )

    # X Axis Setup
    x_vals = [0, 1]
    x_labels = ['Early (D35)', 'Late (D65)']
    
    # Iterate Mutations
    for mutation, col_idx in [('G32A', 1), ('R403C', 2)]:
        pattern_col = f'Pattern_{mutation}'
        
        # Columns to access
        nes_early_col = f'NES_Early_{mutation}'
        nes_traj_col = f'NES_TrajDev_{mutation}' # For tooltip & curve
        nes_late_col = f'NES_Late_{mutation}'
        
        padj_early_col = f'padj_Early_{mutation}'
        padj_traj_col = f'padj_TrajDev_{mutation}'
        padj_late_col = f'padj_Late_{mutation}'
        
        # Sort patterns so rare ones are on top (drawn last)
        counts = df_scope[pattern_col].value_counts()
        # Sort: Frequent -> Rare
        sorted_patterns = counts.index.tolist()
        # We want to DRAW Frequent first (bottom), Rare last (top)
        # So we iterate in that order.
        
        # Group by pattern for Legend toggling
        for pattern in sorted_patterns:
            df_pat = df_scope[df_scope[pattern_col] == pattern]
            base_color = PATTERN_COLORS.get(pattern, '#999999')
            pat_desc = get_pattern_desc(pattern)
            
            # Determine Style based on Weight
            # We can't vary line width PER LINE easily in a single trace if we want legend toggling per group.
            # But we can group them.
            # Actually, for "Weighted", lines have different widths based on PATTERN frequency usually?
            # In viz_bump_charts.py, weight is by PATTERN frequency category.
            # So all lines of a pattern share the same weight category.
            # This is great! We can set line width per pattern.
            
            lw = 1.0 # Default uniform
            opacity = 0.5
            
            if mode == 'weighted' and weight_cats:
                cat = weight_cats.get(pattern, 'rare')
                if cat == 'dominant':  lw = 1.0; opacity = 0.3
                elif cat == 'common':  lw = 2.0; opacity = 0.6
                elif cat == 'uncommon': lw = 3.0; opacity = 0.8
                elif cat == 'rare':    lw = 4.0; opacity = 1.0
            
            # For Rank, we might need to invert Y axis or handle it. 
            # Plotly doesn't easily support inverted Y for shared axes if we don't set it globally.
            # We'll set 'autorange="reversed"' in layout for rank.

            # Prepare Trace Data
            x_combined = []
            y_combined = []
            text_combined = []
            
            # Check if we need curves
            # Only curve if 'Sig_TrajDev' is true (from viz_bump_charts logic)
            # We need to re-check this logic. viz_bump_charts adds 'Sig_TrajDev_{mut}' column.
            # We should check if that column exists or re-derive it.
            # It was added in load_data(), so it should be there.
            sig_traj_col = f'Sig_TrajDev_{mutation}'
            
            for _, row in df_pat.iterrows():
                # Values
                val_e = row.get(f'Rank_Early_{mutation}' if y_type == 'rank' else nes_early_col)
                val_l = row.get(f'Rank_Late_{mutation}' if y_type == 'rank' else nes_late_col)
                
                if pd.isna(val_e) or pd.isna(val_l): continue
                
                # Tooltip Data
                nes_e = row.get(nes_early_col, np.nan)
                nes_t = row.get(nes_traj_col, np.nan)
                nes_l = row.get(nes_late_col, np.nan)
                
                pv_e = row.get(padj_early_col, np.nan)
                pv_t = row.get(padj_traj_col, np.nan)
                pv_l = row.get(padj_late_col, np.nan)
                
                star_e = get_significance_star(pv_e)
                star_t = get_significance_star(pv_t)
                star_l = get_significance_star(pv_l)
                
                hover_text = (
                    f"<b>{row['pathway_id']}</b><br>"
                    f"Database: {row.get('database', 'N/A')}<br>"
                    f"Pattern: {pattern}<br>"
                    f"<br>"
                    f"<b>NES Values:</b><br>"
                    f"Early: {nes_e:.2f}{star_e} (p={pv_e:.2e})<br>"
                    f"TrajDev: {nes_t:.2f}{star_t} (p={pv_t:.2e})<br>"
                    f"Late: {nes_l:.2f}{star_l} (p={pv_l:.2e})<br>"
                    f"<br>"
                    f"<i>{pat_desc}</i>"
                )
                
                # Coordinates
                # If curved
                should_curve = use_curve and row.get(sig_traj_col, False)
                
                if should_curve:
                    # Calculate Bezier
                    # Control point logic from viz_bump_charts
                    traj_val = row.get(nes_traj_col, 0)
                    if pd.isna(traj_val): traj_val = 0
                    
                    y_mid = (val_e + val_l) / 2
                    
                    if y_type == 'rank':
                        # Approx scale for rank
                        # Max rank estimate
                        max_rank = len(df_scope)
                        scale = max_rank / 10.0
                        offset = -1 * traj_val * scale * 0.5 # curve_strength 0.5
                    else:
                        offset = traj_val * 0.5
                        
                    y_control = y_mid + offset
                    
                    bx, by = get_bezier_curve((0, val_e), (0.5, y_control), (1, val_l), n=30)
                    
                    x_combined.extend(bx.tolist() + [None])
                    y_combined.extend(by.tolist() + [None])
                    # Repeat hover text for all points in curve + None
                    text_combined.extend([hover_text] * len(bx) + [None])
                    
                else:
                    # Straight line
                    x_combined.extend([0, 1, None])
                    y_combined.extend([val_e, val_l, None])
                    text_combined.extend([hover_text, hover_text, None])

            if not x_combined: continue

            # Add Trace
            # Use Scattergl for performance if many points
            trace_cls = go.Scattergl if len(x_combined) > 1000 else go.Scatter
            
            fig.add_trace(
                trace_cls(
                    x=x_combined,
                    y=y_combined,
                    mode='lines',
                    line=dict(color=base_color, width=lw),
                    opacity=opacity,
                    name=pattern,
                    legendgroup=pattern,
                    showlegend=(col_idx==1), # Show legend once
                    text=text_combined,
                    hoverinfo='text'
                ),
                row=1, col=col_idx
            )

    # Layout Updates
    title_suffix = f"{scope.capitalize()} | {mode.capitalize()} | {y_type.upper()}"
    if use_curve: title_suffix += " | Curved"
    
    layout_args = dict(
        title=f"Interactive Bump Chart: {title_suffix}",
        template="plotly_white",
        height=800,
        hovermode="closest",
        legend=dict(title="Patterns (Click to Toggle)", itemclick="toggle", itemdoubleclick="toggleothers"),
    )
    
    # Axis configuration
    if y_type == 'rank':
        layout_args['yaxis'] = dict(autorange="reversed", title="Rank")
    else:
        layout_args['yaxis'] = dict(title="NES")
        
    layout_args['xaxis'] = dict(tickmode='array', tickvals=[0, 1], ticktext=['Early (D35)', 'Late (D65)'])
    layout_args['xaxis2'] = dict(tickmode='array', tickvals=[0, 1], ticktext=['Early (D35)', 'Late (D65)'])

    fig.update_layout(**layout_args)

    # Save
    filename = f"bump_{scope}_{mode}_{y_type}"
    if use_curve: filename = f"bump_{scope}_curved_{y_type}" # Match naming convention roughly
    # Naming convention from viz_bump_charts: 
    # uniform_nes, uniform_rank
    # weighted_nes, weighted_rank
    # curved_nes, curved_rank
    # So basically: bump_{scope}_{suffix}.html
    
    suffix = f"{mode}_{y_type}"
    if use_curve: suffix = f"curved_{y_type}" # Curved implies weighted usually in existing script, but we can keep it simple
    
    # Adjust filename to match request of 'variants'
    # Request said: "For each non *_highlight_* static variant"
    # Static variants: bump_focused_uniform_nes, bump_focused_curved_nes, etc.
    
    out_name = f"interactive_bump_{scope}_{suffix}.html"
    out_path = OUTPUT_DIR / out_name
    fig.write_html(out_path)
    print(f"  Saved: {out_path}")


def main():
    print("=" * 80)
    print("INTERACTIVE BUMP CHART GENERATOR")
    print("=" * 80)
    
    # 1. Load and Prepare Data
    print("Loading data...")
    df = load_data()
    df = prepare_data_with_pvals(df)
    
    # 2. Define Variants
    # Match the static variants from viz_bump_charts.py (excluding highlights)
    variants = []
    
    for scope in ['focused', 'significant']:
        # Uniform
        variants.append({'scope': scope, 'mode': 'uniform', 'y_type': 'nes'})
        variants.append({'scope': scope, 'mode': 'uniform', 'y_type': 'rank'})
        
        # Weighted
        variants.append({'scope': scope, 'mode': 'weighted', 'y_type': 'nes'})
        variants.append({'scope': scope, 'mode': 'weighted', 'y_type': 'rank'})
        
        # Curved (NES)
        variants.append({'scope': scope, 'mode': 'weighted', 'y_type': 'nes', 'curve': True})
        
        # Curved (Rank) - specifically requested for significant, but we can do both if useful. 
        # Viz_bump_charts only does curved_rank for significant. We'll stick to that to match 1:1 if desired,
        # but user said "For each ... variant", implying existings. 
        # But specifically mentioned "Curved Rank (New Request) ... if scope == 'significant'" in viz_bump_charts.
        if scope == 'significant':
            variants.append({'scope': scope, 'mode': 'weighted', 'y_type': 'rank', 'curve': True})
            
    # 3. Generate
    for config in variants:
        create_interactive_plot(df, config)
        
    print("\nDone!")

if __name__ == '__main__':
    main()